demo(graphics)
install.packages("slidify")
find_rtools()
find.package("devtools")
clear
cls
quit()
find.package("devtools")
## compute and cache the inverse matrix
## by using lexical scoping
## create a method for the matrix
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## get or compute the cache inverse matrix
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
m1 <- matrix(nrow=2, ncol=2)
m1[1,1] <- 4
m1[1,2] <- 0
m1[2,1] <- 0
m1[2,2] <- 20
m2 <- makeCacheMatrix(m1)
m2
m2$get
m2$get()
m3 <- cacheSolve(m2)
m3
m2*m3
m1*m3
m3 <- cacheSolve(m2)
m3
m2
m2$get
m2$get()
m2$get()*m3
m1 <- makeCacheMatrix(m1)
m1
m1$get()
m1$get()
m1$get()
## compute and cache the inverse matrix
## by using lexical scoping
## create a method for the matrix
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## get or compute the cache inverse matrix
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
testAssignment2 <-function() {
m1 <- matrix(nrow=2, ncol=2)
m1[1,1] <- 4
m1[1,2] <- 0
m1[2,1] <- 0
m1[2,2] <- 20
m <- makeCacheMatrix(m1)
message("showing matrix* contents")
m$get()
m
minv <- cacheSolve(m)
minv
##m1*m3
m$get()*m3
}
testassignment()
testAssignment2()
setwd("~/cursos/cursoRprog2")
## compute and cache the inverse matrix
## by using lexical scoping
## create a method for the matrix
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinverse <- function(solve) inverse <<- solve
getinverse <- function() inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## get or compute the cache inverse matrix
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinverse()
if(!is.null(inverse)) {
message("getting cached data")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinverse(inverse)
inverse
}
## function to test the assignment
testAssignment2 <-function() {
m1 <- matrix(nrow=2, ncol=2)
m1[1,1] <- 4
m1[1,2] <- 0
m1[2,1] <- 0
m1[2,2] <- 20
m <- makeCacheMatrix(m1)
message("showing contents of the special matrix")
m$get()
print(m)
minv <- cacheSolve(m)
print(minv) ## showing the inverse matrix
m1*minv ## showing that product is the identity matrix
minv2 <- cacheSolve(m)
print(minv2) ## showing the cache inverse matrix
m$get()*minv2 ## showing that product is the identity matrix
}
testAssignment2()
testAssignment2 <-function() {
m1 <- matrix(nrow=2, ncol=2)
m1[1,1] <- 4
m1[1,2] <- 0
m1[2,1] <- 0
m1[2,2] <- 20
m <- makeCacheMatrix(m1)
message("showing contents of the special matrix")
print(m$get())
minv <- cacheSolve(m)
print(minv) ## showing the inverse matrix
m1*minv ## showing that product is the identity matrix
minv2 <- cacheSolve(m)
print(minv2) ## showing the cache inverse matrix
m$get()*minv2 ## showing that product is the identity matrix
}
testAssignment2()
testAssignment2 <-function() {
m1 <- matrix(nrow=2, ncol=2)
m1[1,1] <- 4
m1[1,2] <- 0
m1[2,1] <- 0
m1[2,2] <- 20
m <- makeCacheMatrix(m1)
message("showing contents of the special matrix")
print(m$get())
minv <- cacheSolve(m)
print(minv) ## showing the inverse matrix
message("compute product to identity matrix")
m1*minv
minv2 <- cacheSolve(m)
print(minv2) ## showing the cache inverse matrix
message("compute product to identity matrix")
m$get()*minv2
}
testAssignment2()
testAssignment2 <-function() {
m1 <- matrix(nrow=2, ncol=2)
m1[1,1] <- 4
m1[1,2] <- 0
m1[2,1] <- 0
m1[2,2] <- 20
m <- makeCacheMatrix(m1)
print("showing contents of the special matrix")
print(m$get())
minv <- cacheSolve(m)
print(minv) ## showing the inverse matrix
print("compute product to identity matrix")
m1*minv
minv2 <- cacheSolve(m)
print(minv2) ## showing the cache inverse matrix
print("compute product to identity matrix")
m$get()*minv2
}
testAssignment2()
testAssignment2 <-function() {
m1 <- matrix(nrow=2, ncol=2)
m1[1,1] <- 4
m1[1,2] <- 0
m1[2,1] <- 0
m1[2,2] <- 20
m <- makeCacheMatrix(m1)
print("showing contents of the special matrix")
print(m$get())
minv <- cacheSolve(m)
print("showing inverse matrix")
print(minv) ## showing the inverse matrix
print("compute product to identity matrix")
m1*minv
minv2 <- cacheSolve(m)
print("showing inverse matrix again")
print(minv2) ## showing the cache inverse matrix
print("compute product to identity matrix")
m$get()*minv2
}
testAssignment2()
testAssignment2 <-function() {
m1 <- matrix(nrow=2, ncol=2)
m1[1,1] <- 4
m1[1,2] <- 0
m1[2,1] <- 0
m1[2,2] <- 20
m <- makeCacheMatrix(m1)
print("showing contents of the special matrix")
print(m$get())
minv <- cacheSolve(m)
print("showing inverse matrix")
print(minv) ## showing the inverse matrix
print("compute product to identity matrix")
print(m1*minv)
minv2 <- cacheSolve(m)
print("showing inverse matrix again")
print(minv2) ## showing the cache inverse matrix
print("compute product to identity matrix")
m$get()*minv2
}
testAssignment2()
